<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
    <title>NeHe-EPUB-02</title>
    <link type="text/css" href="../css/NeHe-EPUB.css" rel="stylesheet"/>
    <link type="text/css" href="../css/prism.css" rel="stylesheet"/>
    <script src="../js/prism.js"></script>
    <meta charset="utf-8"/>
</head>
<body>
<h2>Lesson 19 - Particle Engines</h2>

<p>A particle system is a technique in game physics, motion graphics, and computer graphics that uses a large number of very small sprites, 3D models, or other graphic objects to simulate certain kinds of &quot;fuzzy&quot; phenomena, which are otherwise very hard to reproduce with conventional rendering techniques - usually highly chaotic systems, natural phenomena, or processes caused by chemical reactions. The algorithmic implementation of such particle systems is often referred to as a particle engine. This lesson is a demonstration of two such particle engines.</p>
<p>In contrast to the last lesson, this one is fairly complex for two reasons. First, the support by three.js for particle engines is relatively primitive so the user has to do a bit more work than for quadrics. Secondly, the particle engine support in three.js is relatively simple in that it only support simple image-based sprites. And those sprites (like the sprites we saw in lesson 13) always face the camera, so they're not very flexible.</p>
<p>So we'll also implement our own particle engine which will demonstrate the basic principles. The tradeoff is that while the three.js particle system can handle a huge number of particles and still be performant, our own particle engine will bog down with a far smaller number of particles.</p>
<p>We initialize the gfxScene object same as always. We also declare some global vars:</p>

<pre><code class="language-javascript">var ELEV         = 25;
var DISTRIBX     = 20;
var DISTRIBZ     = 20;
var DELTA_ELEV   = 10;
var FLOOR_REPEAT = 5;
var clock;
var particleSystem;		
var cannon       = null;
var beachBall    = null;</code></pre>

<p>We'll go over what each of these is for as we go along. Next step is to instantiate the scene, which is pretty standard. We do specify a floor of size 5x5 tiles so we end up with a 20x20 checkerboard. Then we call initDemo, which is where it gets interesting.</p>
<p></p>
<p>First, we instantiate the three.js <span class="inline-code">Clock</span> object:</p>

<pre><code class="language-javascript">clock = new THREE.Clock(true);</code></pre>

<p>We use the clock to control the degree of motion of the three.js particle system sprites. Then we createa simple wire-frame box mesh (in red), just as a visual reference. The box is the same size as the checkerboard floor.</p>

<pre><code class="language-javascript">var cubeGeometry = new THREE.BoxGeometry( 10, 10, 10 );
var cubeMaterial = new THREE.MeshBasicMaterial( { wireframe:true, color : 0xff0000 } );
cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
cube.position.set(0,0,0);
gfxScene.add(cube);</code></pre>

<p>First, we instantiate the three.js particle system by calling <span class="inline-code">createParticleSystem</span>, which returns the particle system &quot;mesh&quot; which we add to the scene.</p>

<pre><code class="language-javascript">particleSystem = createParticleSystem();
gfxScene.add(particleSystem);</code></pre>

<p>Let's look at the code in <span class="inline-code">createParticleSystem</span>. We first set a &quot;constant&quot; that is the number of particles in the system. Then we allocate a plain geometry that will hold all the verticies which are the &quot;particles&quot;.</p>


<pre><code class="language-javascript">var PARTICLE_COUNT = 500;
var particles = new THREE.Geometry();</code></pre>

<p>Then we create the vertices and add them to the particle's geometry. This loop creates all the vertices in a range of -20 to 20(the size of the checkerboard floor) in all directions, centered around the origin.</p>
<pre><code class="language-javascript">for (var p = 0; p &lt; PARTICLE_COUNT; p++) {
    var y = Math.random() * ELEV - DELTA_ELEV;
    var x = Math.random() * DISTRIBX - FLOOR_REPEAT * 2;
    var z = Math.random() * DISTRIBZ - FLOOR_REPEAT * 2;

	var particle = new THREE.Vector3(x, y, z);
    particles.vertices.push(particle);
}</code></pre>

	<p>			Then we create a material  that will be used to render each vertex of the geometry. The texture we supply is a simple PNG &quot;snowflake&quot; image that is partially transparent:</p>
	<p><img src="images/snowflake_illus.png" width="197" height="195" alt=""/></p>
<pre><code class="language-javascript">var particleMaterial = new THREE.PointsMaterial(
						{ color: 0xffffff,
							size: 0.4,
							map: THREE.ImageUtils.loadTexture("images/snowflake.png"),
							blending: THREE.AdditiveBlending,
							transparent: true
						});</code></pre>

<p>We make the snowflake white at 40% of its natural size and set it to be partially transparent have it blended into the scene. Finally we create the particle system and return it to be added to the scene.</p>

<pre><code class="language-javascript">particleSystem = new THREE.Points(particles, particleMaterial);
return particleSystem;</code></pre>

<p>Before we look at the other particle system, let's take a brief look at how the three.js particle system gets animated. the work gets done in <span class="inline-code">animateParticles</span>.</p>

<pre><code class="language-javascript">function animateParticles() {
    var deltaTime = clock.getDelta();            
    var verts = particleSystem.geometry.vertices;
    
    for (var i = 0; i &lt; verts.length; i++) {
        var vert = verts[i];
        if (vert.y &lt; -10) {
            vert.y = Math.random() * ELEV - DELTA_ELEV;
        }
		vert.y = vert.y - deltaTime;
    }
    particleSystem.geometry.verticesNeedUpdate = true;
}</code></pre>


<p>We start by fetching the &quot;deltaTime&quot;, which is the time in seconds since the animation routine was last called. This is usually about 0.016666 since the animation typically runs around 60 fps 1 second divided by 60 is ~0.016. One of the advantages of using the delta time is that it more or less automatically adjusts the rate of descent of the snowflakes so they fall at the same steady rate since the longer it has been since the last call to delta time, the farther the snowflakes drops. Since the routine is called ~60 times a second, each snowflake falls about 1 unit per second and therefore take about 5-10 seconds to fall through the lower limit (-10).</p>
<p>Then we simply loop through all the verticies adjust the elevation by the deltaTime factor. For each vertex we check if they have already reached the bottom limit. If so, we move the vertex back up near the top. But note that the z and x coordinates are not changed so each vertex just cycles up and down in straight line.</p>
<p>Finally, we notify three.js that we have adjust the vertex positions. Otherwise the mesh would not get updated. And that's it for the three.js particle system.</p>
<p>So now, let's take a look at the significantly more complex home-brewed particle system. This one consists of a &quot;cannon&quot; poking up through the checkerboard floor. It fires a steady stream of colored spheres into the air, randomly altering the speed and direction of the launched &quot;beach balls&quot;. Once launched, the balls are subject to gravity and fall down to bounce across the floor until they fall off, plunging into the nether regions.</p>
<p>So let's go through the code - there's a fair amount of it. First, we instantiate the cannon, which also manages all the beach-ballls:</p>

<pre><code class="language-javascript">cannon = new CANNON.Cannon( { scene : gfxScene,
                              deltaT : 10,
                              xLimit : FLOOR_REPEAT,
                              zLimit : FLOOR_REPEAT});
gfxScene.add( cannon.mesh );</code></pre>
<p>The parameters are the scene itself  (since the cannon creates the beach-balls and adds them to the scene). We also pass in the size of the floor so the cannon knows when the balls have fallen off the floor. deltaT basically controls how fast the cannon tries to fire balls. Making the parameter less than 10 has little effect (at least on my MacBookPro, migh on some much faster systems). Making it larger will greatly reduce the number of balls. We'll cover this shortly.</p>
<p>The Cannon object has the following members:</p>

<pre><code class="language-javascript">this.deltaT   = 0.0;
this.lastT    = 0.0;
this.mesh     = null;
this.magazine = new Array();
this.active   = new Array();
this.xLimit   = 0;
this.zLimit   = 0;
this.radius   = RADIUS;
this.scene    = null;
 this.ballCount = 0;</code></pre>
 
<p>Most are self-explanatory, simply providing local storage. The mesh is the three.js mesh that is the cannon itself. The radius is the radius of the cannon's mouth, but also controls the length of it (10x its radius). the <span class="inline-code">magazine</span> is what it implies, it is the magazine in which the balls not currently launched are stored. Those balls that have been launched are kept in the <span class="inline-code">active</span> array. When a ball falls off the floor and into the nether regions, it is moved from the active array into the magazine and then re-launched. In this way, we don't waste memory and performance by removing and re-creating beach-balls. Each ball is created just once. <span class="inline-code">lastT</span> is the time when we last updated all the balls. As you'll see, we throttle the updates since there is no sense to updating faster than 60 fps.</p>
<p>First, we create the cannon:</p>

<pre><code class="language-javascript">this.radius = BASE_RADIUS;

var geometry = new THREE.CylinderGeometry( this.radius * 2.0,
                                                   this.radius * 3.0,
                                                   this.radius * 10,
                                                   32, 1, true);

var material = new THREE.MeshPhongMaterial( { color : 0xdddddd,
                                                      specular: 0x009900,
                                                      shininess: 30,
                                                      side:THREE.DoubleSide});

this.mesh = new THREE.Mesh( geometry, material );</code></pre>

<p></p>
        
<p>And that's it!  Go on to the next page to see the actual rendered demo in all it's particulate glory!</p>
</body>
</html>